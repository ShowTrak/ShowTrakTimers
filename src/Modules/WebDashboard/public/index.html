<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>ShowTrak Timers</title>
    <meta name="theme-color" content="#0c091c" />
    <link rel="manifest" href="/manifest.webmanifest" />
    <link rel="apple-touch-icon" href="/ui/img/icon.png" />
    <link rel="stylesheet" href="/ui/vendors/bootstrap/css/bootstrap.min.css" />
    <link rel="stylesheet" href="/ui/vendors/bootstrap-icons/font/bootstrap-icons.css" />
    <link rel="stylesheet" type="text/css" href="/ui/vendors/toastify/index.min.css" />
    <link rel="stylesheet" href="/ui/css/main.css" />
    <style>
      html,
      body {
        height: 100%;
      }
      body {
        background: transparent !important;
      }
      /* Web dashboard layout: keep gradient full height and constrain scroll */
      body.web-dashboard {
        min-height: 100vh;
        margin: 0;
        display: flex;
        flex-direction: column;
        background: #0c091c;
        overflow: hidden;
      }
      body.web-dashboard .dragbar.dragbar-web {
        flex: 0 0 auto;
      }
      body.web-dashboard #APPLICATION_CONTAINER {
        position: static;
        width: 100%;
        height: auto !important;
        flex: 1 1 auto;
        min-height: 0;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        background: radial-gradient(circle at 50% 80%, #151232 0%, #0c091c 100%) !important;
      }
      body.web-dashboard #APPLICATION {
        flex: 1 1 auto;
        min-height: 0;
        height: auto !important;
        padding-top: 0 !important;
        display: flex;
        flex-direction: column;
      }
      body.web-dashboard #APPLICATION_CONTENT {
        flex: 1 1 auto;
        min-height: 0;
        width: 100%;
        overflow-y: auto;
        overflow-x: hidden;
      }
      .dragbar.dragbar-web {
        position: sticky;
        top: 0;
        z-index: 1000;
        -webkit-app-region: auto;
        cursor: default;
      }
      .dragbar.dragbar-web {
        padding: 0.5rem 1rem;
        gap: 0.5rem;
      }
      .dragbar.dragbar-web img {
        width: 18px;
        height: 18px;
      }
      .dragbar.dragbar-web .branding {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        text-align: left;
      }
      .connection-status-text {
        font-size: 0.85rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }
      .connection-status-text.status-online {
        color: #0de2a4;
      }
      .connection-status-text.status-offline {
        color: #ff5a5a;
      }
      /* Dashboard grid mimics card spacing of app */
      .dashboard-grid {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: flex-start;
        align-content: flex-start;
        gap: 12px;
      }
      .dashboard-grid.offline .SHOWTRAK_TIMER {
        opacity: 0.35;
        filter: grayscale(1);
        pointer-events: none;
      }
      .dashboard-grid.offline .SHOWTRAK_TIMER .progress-bar {
        background-color: rgba(255, 255, 255, 0.2);
      }
      .badge {
        font-size: 10px;
        padding: 2px 6px;
        border-radius: 999px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(255, 255, 255, 0.06);
      }
      /* Web portal: disable hover effects on timers */
      .SHOWTRAK_TIMER {
        cursor: default !important;
        transition: none !important;
      }
      .SHOWTRAK_TIMER:hover {
        border-color: transparent !important;
      }
      .SHOWTRAK_TIMER:hover .timer-controls-overlay {
        opacity: 0 !important;
        pointer-events: none !important;
      }
      /* Mobile optimizations */
      html,
      body {
        overflow-x: hidden;
      }
      @media (max-width: 768px) {
        /* Make cards full-width on tablets/phones */
        .SHOWTRAK_TIMER {
          width: 100% !important;
          box-sizing: border-box;
        }
      }
      @media (max-width: 420px) {
        /* Slightly compact badges at very small widths */
        .TIMER_ID,
        .TIMER_CONTROLS {
          height: 26px;
          font-size: 0.9rem;
        }
        .SHOWTRAK_TIMER {
          padding: 0.75rem !important;
        }
      }
    </style>
  </head>
  <body class="web-dashboard">
    <div class="dragbar dragbar-web bg-light d-flex align-items-center justify-content-between">
      <div class="branding">
        <img src="/ui/img/icon.png" alt="ShowTrak Logo" />
        <span id="APPLICATION_NAVBAR_TITLE">ShowTrak Timers</span>
      </div>
      <span
        id="connection-status-badge"
        class="connection-status-text status-offline"
        role="status"
        aria-live="polite"
        >Offline</span
      >
    </div>
    <div id="APPLICATION_CONTAINER" class="h-100">
      <div id="APPLICATION" class="container-fluid text-center text-light p-0">
        <div id="APPLICATION_CONTENT" class="p-3 gap-3 flex-wrap">
          <div id="grid" class="dashboard-grid w-100"></div>
        </div>
      </div>
    </div>

    <script src="/socket.io/socket.io.js"></script>
    <script>
      const grid = document.getElementById('grid');
      const statusBadge = document.getElementById('connection-status-badge');
      const LOCAL_STORAGE_KEY = 'showtrak:dashboard:lastTimers';
      const STATUS_CLASS = {
        connected: 'connection-status-text status-online',
        offline: 'connection-status-text status-offline',
      };
      const STATUS_CHIP = {
        connected: 'Connected',
        offline: 'Offline',
      };
      let isSocketConnected = false;

      if (grid) {
        grid.classList.add('offline');
      }

      function h(tag, attrs = {}, children = []) {
        const el = document.createElement(tag);
        Object.entries(attrs).forEach(([k, v]) => {
          if (k === 'class') el.className = v;
          else el.setAttribute(k, v);
        });
        (Array.isArray(children) ? children : [children]).forEach((c) => {
          if (c == null) return;
          el.appendChild(typeof c === 'string' ? document.createTextNode(c) : c);
        });
        return el;
      }

      function setStatus(state, message) {
        if (!statusBadge) return;
        if (!message) {
          statusBadge.classList.add('d-none');
          return;
        }
        const variant = STATUS_CLASS[state] || STATUS_CLASS.offline;
        statusBadge.className = variant;
        statusBadge.textContent = STATUS_CHIP[state] || 'Offline';
        statusBadge.setAttribute('aria-label', message || 'Connection status');
        statusBadge.classList.remove('d-none');
      }

      function toggleTimerGreyout(isOnline) {
        if (!grid) return;
        grid.classList.toggle('offline', !isOnline);
      }

      function markOffline() {
        isSocketConnected = false;
        toggleTimerGreyout(false);
        setStatus('offline', 'Offline');
      }

      function markOnline() {
        isSocketConnected = true;
        toggleTimerGreyout(true);
        setStatus('connected', 'Online');
      }

      function readCachedTimers() {
        try {
          const raw = localStorage.getItem(LOCAL_STORAGE_KEY);
          return raw ? JSON.parse(raw) : [];
        } catch (_err) {
          return [];
        }
      }

      function cacheTimers(timers) {
        try {
          localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(timers || []));
        } catch (_err) {
          // ignore storage quota issues
        }
      }

      function render(timers) {
        grid.innerHTML = '';
        if (!timers || timers.length === 0) {
          grid.appendChild(
            h('div', { class: 'text-muted w-100 text-center py-4' }, 'No timers available yet.')
          );
          return;
        }
        sortByWeight(timers).forEach((t) => {
          const isStopwatch = t.Type === 'STOPWATCH';
          const isCountdown = t.Type === 'COUNTDOWN';
          const elapsed = Number(t?.State?.ElapsedTime || 0);
          const durationMs = isStopwatch ? NaN : coerceDurationMs(t?.Duration);
          const remainingMs = isStopwatch
            ? null
            : sanitizeRemainingMs(t?.State?.RemainingMs, durationMs, elapsed);
          const pct =
            !isStopwatch && Number.isFinite(durationMs) && durationMs > 0
              ? Math.max(
                  0,
                  Math.min(
                    100,
                    ((isCountdown && remainingMs != null ? remainingMs : elapsed) / durationMs) *
                      100
                  )
                )
              : 0;

          const line = isStopwatch
            ? t.State?.ElapsedTimeReadable || '00:00'
            : isCountdown
              ? t.State?.RemainingReadable || formatMsReadable(remainingMs)
              : `${t.State?.ElapsedTimeReadable || '00:00'} / ${t.TotalTimeReadable || '00:00'}`;

          const timerChips = h('div', { class: 'timer-chip-right' }, [
            h('span', { class: 'TIMER_ID d-none' }, `ID: ${t.ID}`),
            h('span', { class: 'TIMER_CONTROLS' }, t.Status || ''),
          ]);
          const card = h(
            'div',
            { class: `SHOWTRAK_TIMER card p-2 ${t.Status || 'STANDBY'}`, id: `TIMER_${t.ID}` },
            [
              timerChips,
              h('h5', { class: 'card-title mb-0 text-start' }, t.Name || 'Timer'),
              h('p', { class: 'card-text mb-0 text-start text-white' }, line),
              h('div', { class: 'progress mt-2' }, [
                h('div', {
                  class: 'progress-bar bg-light',
                  role: 'progressbar',
                  style: `width: ${pct}%`,
                  id: `TIMER_PROGRESS_${t.ID}`,
                }),
              ]),
            ]
          );
          grid.appendChild(card);
        });
      }

      function hydrateFromCacheIfAvailable() {
        const cached = readCachedTimers();
        if (cached.length) {
          render(cached);
          markOffline();
        }
      }

      hydrateFromCacheIfAvailable();
      markOffline();

      const socket = io({
        transports: ['websocket', 'polling'],
        reconnection: true,
        reconnectionAttempts: Infinity,
        reconnectionDelay: 1000,
        reconnectionDelayMax: 10000,
      });

      socket.on('connect', () => {
        markOnline();
      });

      socket.on('timers:update', (timers) => {
        render(timers);
        cacheTimers(timers);
        markOnline();
      });

      socket.on('connect_error', () => {
        markOffline();
      });

      socket.on('disconnect', () => {
        markOffline();
      });

      socket.io.on('reconnect_attempt', (attempt) => {
        markOffline();
      });

      socket.io.on('reconnect_failed', () => {
        markOffline();
      });

      window.addEventListener('online', () => {
        if (!isSocketConnected) {
          markOffline();
        }
      });

      window.addEventListener('offline', () => {
        markOffline();
      });

      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/service-worker.js').catch((err) => {
            console.warn('Service worker registration failed', err);
          });
        });
      }

      function sortByWeight(timers) {
        return (timers || []).slice().sort((a, b) => {
          const aWeight = Number.isFinite(Number(a?.Weight))
            ? Number(a.Weight)
            : Number.MAX_SAFE_INTEGER;
          const bWeight = Number.isFinite(Number(b?.Weight))
            ? Number(b.Weight)
            : Number.MAX_SAFE_INTEGER;
          if (aWeight !== bWeight) return aWeight - bWeight;
          const aId = Number.isFinite(Number(a?.ID)) ? Number(a.ID) : Number.MAX_SAFE_INTEGER;
          const bId = Number.isFinite(Number(b?.ID)) ? Number(b.ID) : Number.MAX_SAFE_INTEGER;
          if (aId !== bId) return aId - bId;
          return (a?.Name || '').localeCompare(b?.Name || '');
        });
      }

      function sanitizeRemainingMs(value, durationMs, elapsedMs) {
        if (Number.isFinite(Number(value))) {
          return Math.max(0, Number(value));
        }
        if (!Number.isFinite(durationMs)) return null;
        return Math.max(0, durationMs - (Number(elapsedMs) || 0));
      }

      function formatMsReadable(ms) {
        if (!Number.isFinite(ms) || ms < 0) ms = 0;
        const totalSeconds = Math.floor(ms / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        if (hours > 0) {
          return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
        }
        return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
      }

      function coerceDurationMs(value) {
        if (typeof value === 'number' && Number.isFinite(value)) return value;
        if (value == null) return NaN;
        if (typeof value === 'string') {
          const v = value.trim();
          if (/^\d+$/.test(v)) {
            const n = Number(v);
            return Number.isFinite(n) ? n : NaN;
          }
          if (/^\d{1,2}:\d{2}(:\d{2})?$/.test(v)) {
            const parts = v.split(':').map(Number);
            if (parts.some((n) => !Number.isFinite(n))) return NaN;
            let h = 0,
              m = 0,
              s = 0;
            if (parts.length === 2) {
              [m, s] = parts;
            } else {
              [h, m, s] = parts;
            }
            return (h * 3600 + m * 60 + s) * 1000;
          }
        }
        return NaN;
      }
    </script>
  </body>
</html>
